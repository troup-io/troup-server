### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Label {
  background: String!
  createdAt: DateTime!
  id: Int!
  isGlobal: Boolean
  project: Project
  projectId: Int
  team: Team!
  teamId: Int!
  tickets(after: TicketWhereUniqueInput, before: TicketWhereUniqueInput, first: Int, last: Int, orderBy: TicketOrderByInput, where: TicketWhereInput): [Ticket!]!
  updatedAt: DateTime!
  value: String!
}

input LabelFilter {
  every: LabelWhereInput
  none: LabelWhereInput
  some: LabelWhereInput
}

input LabelOrderByInput {
  background: OrderByArg
  createdAt: OrderByArg
  foreground: OrderByArg
  id: OrderByArg
  isGlobal: OrderByArg
  projectId: OrderByArg
  teamId: OrderByArg
  updatedAt: OrderByArg
  value: OrderByArg
}

input LabelWhereInput {
  AND: [LabelWhereInput!]
  background: StringFilter
  createdAt: DateTimeFilter
  foreground: NullableStringFilter
  id: IntFilter
  isGlobal: NullableBooleanFilter
  NOT: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  project: ProjectWhereInput
  projectId: NullableIntFilter
  team: TeamWhereInput
  teamId: IntFilter
  tickets: TicketFilter
  updatedAt: DateTimeFilter
  value: StringFilter
}

input LabelWhereUniqueInput {
  id: Int
}

type Mutation {
  """Check if a team by the given name already exists."""
  checkTeamName(
    """Team name to check against."""
    teamName: String!
  ): Boolean

  """Create a new global label."""
  createGlobalLabel(
    """The color of the label."""
    color: String

    """The value of the label."""
    value: String!
  ): Label

  """Create a new project."""
  createProject(
    """An array of user IDs to associate as members."""
    members: [Int!]

    """Name of the project to create."""
    name: String!
  ): Project

  """Create a new ticket."""
  createTicket(
    """The content of the ticket."""
    body: String!
    labels: [String!]

    """The project to associate this ticket with."""
    projectId: Int!

    """Title of the ticket to create."""
    title: String!
  ): Ticket

  """Team sign in with an email and return the token and user."""
  signinTeam(
    """The user's email address."""
    email: String!

    """The user's password."""
    password: String!

    """The team's ID."""
    teamId: Int!
  ): TeamSigninData

  """General sign in with an email and return the token and user."""
  signinUser(
    """The user's email address."""
    email: String!

    """The user's password."""
    password: String!
  ): UserData

  """
  Create a user and the relevant profile, along with the team and relevant profile.
  """
  signupTeam(
    """The user's email address."""
    email: String!

    """The user's first name."""
    firstName: String!

    """The user's last name."""
    lastName: String!

    """The user's password."""
    password: String!

    """The name of the team being created. Must be unique."""
    teamName: String!
  ): TeamSignupData

  """Team creation flow. The created user is the team's owner."""
  signupUser(
    """The user's email address."""
    email: String!

    """The user's first name."""
    firstName: String!

    """The user's last name."""
    lastName: String!

    """The user's password."""
    password: String!

    """The ID of the team sign up with."""
    teamId: Int!
  ): UserData
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Project {
  createdAt: DateTime!
  id: Int!
  labels(after: LabelWhereUniqueInput, before: LabelWhereUniqueInput, first: Int, last: Int, orderBy: LabelOrderByInput, where: LabelWhereInput): [Label!]!
  members(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, where: UserWhereInput): [User!]!
  name: String!
  sequence: Int!
  team: Team!
  teamId: Int!
  tickets(after: TicketWhereUniqueInput, before: TicketWhereUniqueInput, first: Int, last: Int, orderBy: TicketOrderByInput, where: TicketWhereInput): [Ticket!]!
  updatedAt: DateTime!
}

input ProjectFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  labels: LabelFilter
  members: UserFilter
  name: StringFilter
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  sequence: IntFilter
  team: TeamWhereInput
  teamId: IntFilter
  tickets: TicketFilter
  updatedAt: DateTimeFilter
}

type Query {
  """Check if a user already exists while creating"""
  checkIfUserExists(
    """User's email to check against."""
    email: String!
  ): Boolean

  """Get all the teams the user is associated with as an owner or a member."""
  getUserTeams: UserTeamDetails

  """Get all the projects of a particular team."""
  projects: [Project!]

  """Fetch the information of a particular team by name."""
  teamDetailsFromName(
    """Team's name to fetch data for."""
    name: String!
  ): TeamAuthInfoData

  """Fetch the details of all the teams of a particular user."""
  teams: [Team!]

  """
  Get bare-minimal user details to populate the interface and identify the user.
  """
  userDetails: UserDetails
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Team {
  adminEmail: String
  createdAt: DateTime!
  displayName: String
  id: Int!
  maxMembers: Int!
  members(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  name: String!
  owner: User!
  ownerId: Int!
  updatedAt: DateTime!
}

type TeamAuthInfoData {
  displayName: String
  id: Int!
  name: String!
}

input TeamFilter {
  every: TeamWhereInput
  none: TeamWhereInput
  some: TeamWhereInput
}

input TeamOrderByInput {
  adminEmail: OrderByArg
  createdAt: OrderByArg
  displayName: OrderByArg
  id: OrderByArg
  maxMembers: OrderByArg
  name: OrderByArg
  ownerId: OrderByArg
  updatedAt: OrderByArg
}

type TeamSigninData {
  """The encoded JWT token."""
  token: String

  """The user object."""
  user: User
}

type TeamSignupData {
  """The team object."""
  team: Team

  """The encoded JWT token."""
  token: String

  """The user object."""
  user: User
}

input TeamWhereInput {
  adminEmail: NullableStringFilter
  AND: [TeamWhereInput!]
  createdAt: DateTimeFilter
  displayName: NullableStringFilter
  id: IntFilter
  labels: LabelFilter
  maxMembers: IntFilter
  members: UserFilter
  name: StringFilter
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  owner: UserWhereInput
  ownerId: IntFilter
  projects: ProjectFilter
  tickets: TicketFilter
  updatedAt: DateTimeFilter
}

input TeamWhereUniqueInput {
  id: Int
  name: String
}

type Ticket {
  author: User!
  authorId: Int!
  body: String!
  createdAt: DateTime!
  id: Int!
  labels(after: LabelWhereUniqueInput, before: LabelWhereUniqueInput, first: Int, last: Int, orderBy: LabelOrderByInput, where: LabelWhereInput): [Label!]!
  project: Project!
  projectId: Int!
  sequence: Int!
  team: Team!
  teamId: Int!
  title: String!
  updatedAt: DateTime!
}

input TicketFilter {
  every: TicketWhereInput
  none: TicketWhereInput
  some: TicketWhereInput
}

input TicketOrderByInput {
  authorId: OrderByArg
  body: OrderByArg
  createdAt: OrderByArg
  id: OrderByArg
  projectId: OrderByArg
  sequence: OrderByArg
  teamId: OrderByArg
  title: OrderByArg
  updatedAt: OrderByArg
}

input TicketWhereInput {
  AND: [TicketWhereInput!]
  author: UserWhereInput
  authorId: IntFilter
  body: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  labels: LabelFilter
  NOT: [TicketWhereInput!]
  OR: [TicketWhereInput!]
  project: ProjectWhereInput
  projectId: IntFilter
  sequence: IntFilter
  team: TeamWhereInput
  teamId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input TicketWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  memberTeams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int, orderBy: TeamOrderByInput, where: TeamWhereInput): [Team!]!
  ownerTeams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int, orderBy: TeamOrderByInput, where: TeamWhereInput): [Team!]!
  updatedAt: DateTime!
}

type UserData {
  """The encoded JWT token."""
  token: String

  """The user object."""
  user: User
}

type UserDetails {
  createdAt: DateTime!
  email: String!
  id: Int!
  profile: UserProfile!
  updatedAt: DateTime!
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  createdAt: OrderByArg
  email: OrderByArg
  id: OrderByArg
  password: OrderByArg
  updatedAt: OrderByArg
}

type UserProfile {
  createdAt: DateTime!
  firstName: String!
  id: Int!
  lastName: String!
  professionalCompetence: String
  updatedAt: DateTime!
  utm_campaign: String
  utm_content: String
  utm_medium: String
  utm_source: String
  utm_term: String
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  createdAt: DateTimeFilter
  firstName: StringFilter
  id: IntFilter
  isSuperAdmin: BooleanFilter
  lastName: StringFilter
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  professionalCompetence: NullableStringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
  utm_campaign: NullableStringFilter
  utm_content: NullableStringFilter
  utm_medium: NullableStringFilter
  utm_source: NullableStringFilter
  utm_term: NullableStringFilter
}

type UserTeamDetails {
  id: Int!
  memberTeams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int, orderBy: TeamOrderByInput, where: TeamWhereInput): [Team!]!
  ownerTeams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int, orderBy: TeamOrderByInput, where: TeamWhereInput): [Team!]!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  memberTeams: TeamFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  ownerTeams: TeamFilter
  password: StringFilter
  profile: UserProfileWhereInput
  projects: ProjectFilter
  tickets: TicketFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
